<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drbaph | Creative Coding Gallery</title>
    <meta name="description" content="Explore a mesmerizing collection of generative art, interactive apps, and algorithmic designs. Where code meets creativity and art.">

    <link rel="icon" type="image/x-icon" href="/favicon/favicon.ico">

  
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/favicon/android-chrome-512x512.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <meta name="theme-color" content="#ffffff">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Drbaph | Creative Coding Galler">
    <meta property="og:description" content="Explore a mesmerizing collection of generative art, interactive apps, and algorithmic designs. Where code meets creativity and art.">
    <meta property="og:image" content="https://i.ibb.co/xS831xRK/og.jpg">
    <meta property="og:url" content="https://drbaph.is-a.dev/">
    <meta property="og:type" content="website">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Drbaph | Creative Coding Gallery">
    <meta name="twitter:description" content="Explore a mesmerizing collection of generative art, interactive apps, and algorithmic designs. Where code meets creativity and art.">
    <meta name="twitter:image" content="https://i.ibb.co/xS831xRK/og.jpg">

    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --accent-color: #00c8ff;
            --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --hover-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent; /* Remove blue highlight on tap for all elements */
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            overflow-x: hidden;
            position: relative;
            -webkit-touch-callout: none; /* Prevent callout to copy image, etc when tap to hold */
        }

        #particles-canvas, #wave-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        #wave-canvas {
            opacity: 0.3;
        }

        #particles-canvas {
            opacity: 0.5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            padding: 3rem 1rem;
        }

        .title-container {
            height: 4.5rem; /* Fixed height to prevent content shifting */
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
        }

        h1 {
            font-size: 3.5rem;
            background: linear-gradient(90deg, var(--accent-color), #ff00aa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-block;
            white-space: nowrap;
            position: relative;
        }
        
        .cursor {
            display: inline-block;
            width: 3px;
            height: 50px;
            background-color: var(--accent-color);
            margin-left: 5px;
            animation: cursor-blink 1s infinite;
            vertical-align: middle;
        }
        
        @keyframes cursor-blink {
            0%, 49% {
                opacity: 1;
            }
            50%, 100% {
                opacity: 0;
            }
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            margin: 4rem 0;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--card-shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            height: 100%;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: var(--hover-shadow);
        }

        .card-image {
            width: 100%;
            height: 200px;
            overflow: hidden;
            position: relative;
        }

        .card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.3s ease;
        }

        .card-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card:hover .card-image img {
            opacity: 0;
        }

        .card:hover .card-video {
            opacity: 1;
        }

        .card-content {
            padding: 1.5rem;
            position: relative;
        }

        .card-title {
            font-size: 1.5rem;
            margin-bottom: 0.8rem;
            color: var(--accent-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title-text {
            margin-right: auto;
        }

        .card-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .card-description {
            color: var(--text-secondary);
            line-height: 1.6;
        }

        footer {
            text-align: center;
            padding: 3rem 1rem;
            margin-top: 4rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .site-links {
            margin-bottom: 2rem;
        }

        .site-links a {
            color: var(--text-primary);
            text-decoration: none;
            margin: 0 1rem;
            font-weight: 500;
            position: relative;
            padding-bottom: 4px;
        }

        .site-links a::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 2px;
            background-color: var(--accent-color);
            transition: width 0.3s ease;
        }

        .site-links a:hover {
            color: var(--accent-color);
        }

        .site-links a:hover::after {
            width: 100%;
        }

        .social-icons {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .social-icons a {
            color: var(--text-secondary);
            font-size: 1.5rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.05);
            text-decoration: none;
        }

        .social-icons a:hover {
            color: var(--accent-color);
            transform: translateY(-5px);
            background-color: rgba(255, 255, 255, 0.1);
        }

        .copyright {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Demo button styles */
        .demo-btn {
            display: inline-block;
            background-color: var(--accent-color);
            color: var(--bg-color);
            padding: 6px 12px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 0.8rem;
            text-decoration: none;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
        }

        .demo-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 200, 255, 0.4);
            background-color: #00d9ff;
        }

        .repo-btn {
            display: inline-block;
            background-color: rgba(0, 200, 255, 0.15);
            color: var(--accent-color);
            padding: 6px 12px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 0.8rem;
            text-decoration: none;
            transition: all 0.3s ease;
            border: 1px solid var(--accent-color);
            cursor: pointer;
        }

        .repo-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 200, 255, 0.2);
            background-color: rgba(0, 200, 255, 0.25);
        }

        /* Pong game styles */
        .pong-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            pointer-events: none;
        }

        .pong-paddle {
            position: absolute;
            width: 15px;
            height: 120px;
            background-color: white;
            border-radius: 8px;
            z-index: 10000;
            transition: box-shadow 0.1s ease-in-out;
        }

        .paddle-glow {
            box-shadow: 0 0 15px 5px rgba(0, 255, 0, 0.7);
        }

        .pong-paddle-left {
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .pong-paddle-right {
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .pong-ball {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        .ball-tracer {
            position: absolute;
            border-radius: 50%;
            background-color: white;
            z-index: 9999;
            opacity: 0.6;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .ball-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }

        .pong-score {
            position: fixed;
            font-size: 48px;
            color: rgba(255, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            pointer-events: none;
            z-index: 10000;
        }

        .pong-score-left {
            top: 30px;
            left: 30px;
        }

        .pong-score-right {
            top: 30px;
            right: 30px;
        }

        /* Responsive styles */
        @media (max-width: 1200px) {
            .card-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2.5rem;
            }

            .card-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .site-links a {
                display: block;
                margin: 0.7rem 0;
            }

            .social-icons {
                flex-wrap: wrap;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
            }

            .card-title {
                font-size: 1.2rem;
            }
        }

        .card-buttons a,
        .social-icons a,
        .site-links a {
            -webkit-tap-highlight-color: transparent; /* Explicitly remove for interactive elements */
            outline: none; /* Remove outline for buttons and links */
            user-select: none; /* Prevent text selection on buttons */
        }
    </style>
</head>
<body>
    <canvas id="particles-canvas"></canvas>
    <canvas id="wave-canvas"></canvas>

    <!-- Pong Game Elements -->
    <div class="pong-container" id="pong-container">
        <div class="pong-paddle pong-paddle-left" id="pong-paddle-left"></div>
        <div class="pong-paddle pong-paddle-right" id="pong-paddle-right"></div>
        <div class="pong-ball" id="pong-ball"></div>
        <div class="pong-score pong-score-left" id="pong-score-left">0</div>
        <div class="pong-score pong-score-right" id="pong-score-right">0</div>
        <!-- Ball tracers will be added dynamically -->
        <!-- Sound effects -->
        <audio id="paddle-hit-sound" preload="auto">
            <source src="https://assets.mixkit.co/active_storage/sfx/3005/3005-preview.mp3" type="audio/mpeg">
        </audio>
    </div>

    <div class="container">
        <header>
            <div class="title-container">
                <a id="title-link" href="#" target="_blank">
                    <h1 id="typing-title"></h1>
                </a><span class="cursor"></span>
            </div>
            <p class="subtitle">Exploring the fusion of technology, art, and mathematics through creative coding, interactive projects, and dynamic visualizations.</p>
        </header>

        <div class="card-grid">
            <!-- Card 1 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/wf1.png" alt="Shapes">
                    <video class="card-video" muted loop>
                        <source src="vid/shapes1.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Shapes</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/Drbaph_shapes" class="repo-btn">Code</a>
                            <a href="https://app.drbaph.com/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">An interactive web-based 3D shape visualization tool that renders various geometric shapes in a wireframe style with a dynamic matrix background effect.</p>
                </div>
            </div>

            <!-- Card 2 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/wf6.jpg" alt=".Matrix">
                    <video class="card-video" muted loop>
                        <source src="vid/dot_matrix.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Dot Matrix</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/.matrix" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/.matrix/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description"> Transform images and videos into stunning dot-matrix art with this vanilla JavaScript web app. Features real-time preview, customizable effects, and video processing.</p>
                </div>
            </div>

            <!-- Card 3 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/wf5.jpg" alt="Synthrain">
                    <video class="card-video" muted loop>
                        <source src="vid/synthrain.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Synthrain</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/SynthRain" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/SynthRain/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">Simulating complex particle interactions in a visually appealing and scientifically accurate environment.</p>
                </div>
            </div>

            <!-- Card 4 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/wf4.jpg" alt="Swarm">
                    <video class="card-video" muted loop>
                        <source src="vid/swarm1.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Swarm</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/Swarm" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/Swarm/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">An interactive pointer swarm simulation where a mesmerizing group of pointers follows your cursor, creating dynamic and chaotic patterns.</p>
                </div>
            </div>

            <!-- Card 5 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/wf8.jpg" alt="NeonOracle">
                    <video class="card-video" muted loop>
                        <source src="vid/neonoracle.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Neon Oracle</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/NeonOracle" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/NeonOracle/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">A 3D fractal visualization tool for exploring the beauty and complexity of Mandelbulb fractals.</p>
                </div>
            </div>

            <!-- Card 6 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/wf7.jpg" alt="Project 6">
                    <video class="card-video" muted loop>
                        <source src="vid/aetherstrum.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Aetherstrum</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/AetherStrum" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/AetherStrum/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">An ethereal musical instrument that combines visual art with sound synthesis. Create mesmerizing music by interacting with vibrating strings in a beautiful, particle-rich environment.</p>
                </div>
            </div>

            <!-- Card 7 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/lofilamp.jpg" alt="Project 7">
                    <video class="card-video" muted loop>
                        <source src="vid/lofilamp.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">LofiLamp</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/LofiLamp" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/LofiLamp/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">An interactive Lofi lava lamp visualization with customizable colors, controls, and lofi music. Perfect for relaxation and focus during work or study sessions.</p>
                </div>
            </div>

            <!-- Card 8 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/Ezpiano.jpg" alt="Project 8">
                    <video class="card-video" muted loop>
                        <source src="vid/ezpiano.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">EZ Piano</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/EZPiano" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/EZPiano/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">A beautiful and feature-rich virtual piano with learning mode, multiple songs, and advanced sound options.</p>
                </div>
            </div>

            <!-- Card 9 -->
            <div class="card">
                <div class="card-image">
                    <img src="img/greentendo.png" alt="Project 9">
                    <video class="card-video" muted loop>
                        <source src="vid/greentendo.mp4" type="video/mp4">
                    </video>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <span class="card-title-text">Greentendo</span>
                        <div class="card-buttons">
                            <a href="https://github.com/Saganaki22/Greentendo/" class="repo-btn">Code</a>
                            <a href="https://saganaki22.github.io/Greentendo/" class="demo-btn">DEMO</a>
                        </div>
                    </h3>
                    <p class="card-description">A nostalgic Game Boy simulator featuring classic games like Snake, Pong, Tetris, Space Invaders, and more, built with vanilla JavaScript and styled with modern CSS.</p>
                </div>
            </div>
        </div>

        <footer>
            <div class="site-links">
                <a href="https://drbaph.dev" target="_blank">drbaph.dev</a>
                <a href="https://drbaph.com" target="_blank">drbaph.com</a>
                <a href="https://mandelbulb.xyz" target="_blank">mandelbulb.xyz</a>
                <a href="https://fractalize.xyz" target="_blank">fractalize.xyz</a>
            </div>

            <div class="social-icons">
                <a href="https://x.com/drbaph" target="_blank" aria-label="X / Twitter">
                    <i class="ph ph-x-logo"></i>
                </a>
                <a href="https://www.instagram.com/drbaph" target="_blank" aria-label="Instagram">
                    <i class="ph ph-instagram-logo"></i>
                </a>
                <a href="https://t.me/drbaph" target="_blank" aria-label="Telegram">
                    <i class="ph ph-telegram-logo"></i>
                </a>
                <a href="https://github.com/Saganaki22" target="_blank" aria-label="GitHub">
                    <i class="ph ph-github-logo"></i>
                </a>
                <a href="https://huggingface.co/drbaph" target="_blank" aria-label="HuggingFace">
                    <i class="ph ph-smiley"></i>
                </a>
                <a href="https://matrix.to/#/@drbaph:matrix.org" target="_blank" aria-label="Matrix">
                    <i class="ph-bold ph-chats"></i>
                </a>
            </div>

            <p class="copyright">© 2025 DrBaph. All rights reserved.</p>
        </footer>
    </div>

    <script>
        // Console developer signature
        console.log('%c designed by @drbaph ', 'background: #121212; color: #00FF66; font-size: 16px; font-weight: bold; padding: 5px 10px; border-radius: 5px; border-left: 4px solid #00c8ff;');
        
        // Console typing animation
        (function() {
            const titleElement = document.getElementById('typing-title');
            const titleLink = document.getElementById('title-link');
            const titles = ["drbaph.is-a.dev", "Saganaki22.github.io"];
            const urls = {
                "drbaph.is-a.dev": "https://drbaph.dev",
                "Saganaki22.github.io": "https://github.com/Saganaki22"
            };
            let currentTitleIndex = 0;
            let currentCharIndex = 0;
            let isDeleting = false;
            let typingSpeed = 150; // Base typing speed in ms
            
            function updateTitleLink(currentTitle) {
                // Update the href of the link based on the current title text
                if (currentTitle === titles[0]) {
                    titleLink.href = urls[titles[0]];
                } else if (currentTitle === titles[1]) {
                    titleLink.href = urls[titles[1]];
                }
            }
            
            function typeText() {
                const currentTitle = titles[currentTitleIndex];
                
                // If deleting, remove a character
                if (isDeleting) {
                    titleElement.textContent = currentTitle.substring(0, currentCharIndex - 1);
                    currentCharIndex--;
                } else {
                    // If typing, add a character
                    titleElement.textContent = currentTitle.substring(0, currentCharIndex + 1);
                    currentCharIndex++;
                }
                
                // Update link when full title is shown
                if (currentCharIndex === currentTitle.length) {
                    updateTitleLink(currentTitle);
                }
                
                // Determine typing speed - faster when deleting
                let speed = isDeleting ? typingSpeed / 2 : typingSpeed;
                
                // Randomize typing speed slightly to make it more human-like
                speed = speed + Math.random() * 50 - 25;
                
                // Handle text completion or deletion completion
                if (!isDeleting && currentCharIndex === currentTitle.length) {
                    // Finished typing a word
                    speed = 10000; // Wait 10 seconds before deleting
                    isDeleting = true;
                } else if (isDeleting && currentCharIndex === 0) {
                    // Finished deleting a word
                    isDeleting = false;
                    currentTitleIndex = (currentTitleIndex + 1) % titles.length;
                }
                
                setTimeout(typeText, speed);
            }
            
            // Style the link to inherit the title's appearance
            titleLink.style.textDecoration = "none";
            titleLink.style.color = "inherit";
            
            // Start the typing animation
            typeText();
        })();
        
        // Particle animation
        (function() {
            const canvas = document.getElementById('particles-canvas');
            const ctx = canvas.getContext('2d');
            
            let particles = [];
            const particleCount = 100;
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            function initParticles() {
                particles = [];
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 1,
                        speed: Math.random() * 1 + 0.2,
                        direction: Math.random() * Math.PI * 2,
                        color: `rgba(${Math.floor(Math.random() * 100 + 155)}, ${Math.floor(Math.random() * 100 + 155)}, ${Math.floor(Math.random() * 255)}, 0.7)`
                    });
                }
            }
            
            function drawParticles() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach(particle => {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                    
                    // Update position
                    particle.x += Math.cos(particle.direction) * particle.speed;
                    particle.y += Math.sin(particle.direction) * particle.speed;
                    
                    // Bounce off edges
                    if (particle.x < 0 || particle.x > canvas.width) {
                        particle.direction = Math.PI - particle.direction;
                    }
                    if (particle.y < 0 || particle.y > canvas.height) {
                        particle.direction = -particle.direction;
                    }
                    
                    // Draw connections
                    particles.forEach(otherParticle => {
                        const dx = particle.x - otherParticle.x;
                        const dy = particle.y - otherParticle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 100) {
                            ctx.beginPath();
                            ctx.moveTo(particle.x, particle.y);
                            ctx.lineTo(otherParticle.x, otherParticle.y);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 - distance / 1000})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    });
                });
                
                requestAnimationFrame(drawParticles);
            }
            
            window.addEventListener('resize', function() {
                resizeCanvas();
                initParticles();
            });
            
            resizeCanvas();
            initParticles();
            drawParticles();
        })();
        
        // Sin wave animation
        (function() {
            const canvas = document.getElementById('wave-canvas');
            const ctx = canvas.getContext('2d');
            
            let time = 0;
            const waves = 3;
            const waveColors = [
                'rgba(0, 200, 255, 0.3)',
                'rgba(255, 0, 170, 0.2)',
                'rgba(100, 100, 255, 0.2)'
            ];
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            function drawWaves() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                time += 0.01;
                
                for (let w = 0; w < waves; w++) {
                    ctx.beginPath();
                    
                    // Different parameters for each wave
                    const amplitude = 50 + w * 20; // Height of wave
                    const period = 0.01 - w * 0.002; // How many waves
                    const phaseShift = time * (0.5 + w * 0.2); // Wave movement speed
                    
                    // Start at the left side, slightly off-canvas
                    ctx.moveTo(0, canvas.height / 2 + Math.sin(phaseShift) * amplitude);
                    
                    // Draw the wave across the screen
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height / 2 + 
                                 Math.sin(x * period + phaseShift) * amplitude;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.strokeStyle = waveColors[w];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                requestAnimationFrame(drawWaves);
            }
            
            window.addEventListener('resize', resizeCanvas);
            
            resizeCanvas();
            drawWaves();
        })();
        
        // Pong Game
        (function() {
            // Inactivity timer
            let inactivityTimer;
            let inactivityDelay = 25000; // 25 seconds
            let pongActive = false;
            let gameStarted = false;
            
            // Game elements
            const pongContainer = document.getElementById('pong-container');
            const leftPaddle = document.getElementById('pong-paddle-left');
            const rightPaddle = document.getElementById('pong-paddle-right');
            const ball = document.getElementById('pong-ball');
            const leftScore = document.getElementById('pong-score-left');
            const rightScore = document.getElementById('pong-score-right');
            
            // Sound elements
            const paddleHitSound = document.getElementById('paddle-hit-sound');
            paddleHitSound.volume = 0.25; // Reduced from 0.5 to 0.25 (25% of original volume)
            
            // Sound cooldowns to prevent too many sounds at once
            let paddleSoundCooldown = false;
            
            // Function to play sounds with cooldown
            function playPaddleHitSound() {
                if (!paddleSoundCooldown) {
                    paddleHitSound.currentTime = 0;
                    paddleHitSound.play();
                    paddleSoundCooldown = true;
                    setTimeout(() => { paddleSoundCooldown = false; }, 100);
                }
            }
            
            // Tracer elements
            const tracerCount = 5;
            const tracers = [];
            
            // Create tracer elements
            for (let i = 0; i < tracerCount; i++) {
                const tracer = document.createElement('div');
                tracer.className = 'ball-tracer';
                pongContainer.appendChild(tracer);
                tracers.push(tracer);
            }
            
            // Previous ball positions for tracer effect
            const ballPositions = [];
            
            // Game state
            let gameState = {
                ballX: window.innerWidth / 2,
                ballY: window.innerHeight / 2,
                ballSpeedX: 9.375, // Increased from 7.8125 to 9.375 (20% faster)
                ballSpeedY: 3.75, // Increased from 3.125 to 3.75 (20% faster)
                paddleSpeed: 5,
                leftPaddleY: window.innerHeight / 2 - 60,
                rightPaddleY: window.innerHeight / 2 - 60,
                leftPoints: 0,
                rightPoints: 0,
                paddleHeight: 120,
                paddleWidth: 15,
                ballSize: 20,
                cpuAccuracy: 0.5, // Initial CPU accuracy (50%)
                cpuSkillIncrease: 0.1, // Amount to increase skill by after player scores 5
                cpuDifficultyStage: 0, // Tracks how many times difficulty has increased
                lastBallX: window.innerWidth / 2, // Store previous ball position for better collision
                lastBallY: window.innerHeight / 2,  // Store previous ball position for better collision
                subSteps: 16, // Increased from 12 to 16 for more precise collision detection
                userPaddleExtraWidth: 20, // Increased from 12 to 20 for much wider detection
                speedBoostStage: 0, // Track how many speed boosts have been applied
                originalBallSpeed: 9.375, // Updated from 7.8125 to 9.375 (20% faster)
                collisionCooldown: 0, // Add collision cooldown counter
                explosionOccurred: false, // Track if the explosion at 50 points has occurred
                ballVisible: true, // Track if the ball is visible
                nextExplosionThreshold: 50, // Track when the next explosion should occur
                postExplosionBoost: false, // Track if we're in post-explosion mode (20% boosts)
                lastExplosionScore: 0 // Track the score at which the last explosion occurred
            };
            
            // Game loop variables
            let animationFrame;
            
            // Function to create particle explosion effect
            function createExplosion(x, y) {
                const numParticles = 60;
                const particles = [];
                const colors = ['#FFFFFF', '#00AAFF', '#FF00AA', '#FFFF00', '#00FFAA'];
                
                // Hide the ball
                gameState.ballVisible = false;
                ball.style.display = 'none';
                
                // Hide tracers
                tracers.forEach(tracer => {
                    tracer.style.opacity = '0';
                });
                
                // Create particles
                for (let i = 0; i < numParticles; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'ball-particle';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    
                    // Random size between 2px and 6px
                    const size = Math.random() * 4 + 2;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // Random color
                    particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    // Add to container
                    pongContainer.appendChild(particle);
                    particles.push({
                        element: particle,
                        // Random velocity
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        // Random rotation and scale
                        rotation: Math.random() * 360,
                        rotationSpeed: (Math.random() - 0.5) * 20,
                        opacity: 1
                    });
                }
                
                // Animate particles
                let start = null;
                const duration = 1500; // 1.5 seconds
                
                function animateParticles(timestamp) {
                    if (!start) start = timestamp;
                    const progress = timestamp - start;
                    const normalizedProgress = Math.min(progress / duration, 1);
                    
                    particles.forEach(particle => {
                        // Update position
                        const newX = parseFloat(particle.element.style.left) + particle.vx;
                        const newY = parseFloat(particle.element.style.top) + particle.vy;
                        particle.element.style.left = newX + 'px';
                        particle.element.style.top = newY + 'px';
                        
                        // Update rotation
                        particle.rotation += particle.rotationSpeed;
                        particle.element.style.transform = `rotate(${particle.rotation}deg)`;
                        
                        // Update opacity
                        particle.opacity = 1 - normalizedProgress;
                        particle.element.style.opacity = particle.opacity;
                        
                        // Add gravity effect
                        particle.vy += 0.1;
                    });
                    
                    if (progress < duration) {
                        requestAnimationFrame(animateParticles);
                    } else {
                        // Animation completed
                        particles.forEach(particle => {
                            pongContainer.removeChild(particle.element);
                        });
                        
                        // Show the ball again and reset its speed
                        gameState.ballVisible = true;
                        ball.style.display = 'block';
                        gameState.speedBoostStage = 0;
                        resetBall();
                    }
                }
                
                requestAnimationFrame(animateParticles);
            }
            
            function resetInactivityTimer() {
                clearTimeout(inactivityTimer);
                
                // Only stop pong if it's not yet started or we're clicking something substantive
                if (pongActive && !gameStarted) {
                    stopPong();
                }
                
                inactivityTimer = setTimeout(() => {
                    startPong();
                }, inactivityDelay);
            }
            
            function startPong() {
                pongActive = true;
                gameStarted = true;
                pongContainer.style.display = 'block';
                resetBall();
                gameLoop();
            }
            
            function stopPong() {
                pongActive = false;
                gameStarted = false;
                pongContainer.style.display = 'none';
                cancelAnimationFrame(animationFrame);
                
                // Reset scores
                gameState.leftPoints = 0;
                gameState.rightPoints = 0;
                leftScore.textContent = '0';
                rightScore.textContent = '0';
            }
            
            function resetBall() {
                gameState.ballX = window.innerWidth / 2;
                gameState.ballY = window.innerHeight / 2;
                gameState.lastBallX = gameState.ballX;
                gameState.lastBallY = gameState.ballY;
                
                // Set the base speed based on speed boost stage
                let baseSpeed = gameState.originalBallSpeed;
                
                // Apply progressive speed boosts based on the current stage
                if (gameState.speedBoostStage > 0) {
                    if (gameState.postExplosionBoost) {
                        // After 50 points explosion, apply 20% increases
                        baseSpeed = gameState.originalBallSpeed * Math.pow(1.20, gameState.speedBoostStage);
                    } else {
                        // Before 50 points explosion, apply 25% increases
                        baseSpeed = gameState.originalBallSpeed * Math.pow(1.25, gameState.speedBoostStage);
                    }
                }
                
                // Set random direction but with consistent speed
                gameState.ballSpeedX = Math.random() > 0.5 ? baseSpeed : -baseSpeed;
                
                // Set Y speed with appropriate scaling for boosts
                let ySpeedFactor;
                if (gameState.postExplosionBoost) {
                    ySpeedFactor = Math.pow(1.20, gameState.speedBoostStage);
                } else {
                    ySpeedFactor = Math.pow(1.25, gameState.speedBoostStage);
                }
                
                gameState.ballSpeedY = (Math.random() * 5 - 2.5) * ySpeedFactor;
                
                // Reset ball position history
                ballPositions.length = 0;
            }
            
            // Helper function to check if ball collides with a paddle
            function checkPaddleCollision(x, y, paddleX, paddleY, paddleWidth, paddleHeight) {
                return (
                    x - gameState.ballSize/2 <= paddleX + paddleWidth &&
                    x + gameState.ballSize/2 >= paddleX &&
                    y >= paddleY - gameState.ballSize/2 && // Added ball size to increase vertical collision area
                    y <= paddleY + paddleHeight + gameState.ballSize/2 // Added ball size to increase vertical collision area
                );
            }
            
            // Special function for user paddle with expanded hitbox - IMPROVED
            function checkUserPaddleCollision(x, y, lastX, lastY, paddleX, paddleY, paddleWidth, paddleHeight) {
                // Regular collision with expanded vertical area
                const normalCollision = checkPaddleCollision(x, y, paddleX, paddleY, paddleWidth, paddleHeight);
                
                // Check if ball has "tunneled" through the paddle between frames
                const ballWasInFrontOfPaddle = lastX < paddleX;
                const ballIsAfterPaddle = x > paddleX + paddleWidth;
                const tunnelY = y >= paddleY - gameState.ballSize && y <= paddleY + paddleHeight + gameState.ballSize;
                const tunneled = ballWasInFrontOfPaddle && ballIsAfterPaddle && tunnelY;
                
                // Extra buffer for right side boundary - make hitbox even bigger
                const extendedCollision = checkPaddleCollision(
                    x, y,
                    paddleX - gameState.userPaddleExtraWidth * 1.5, // Extend paddle hitbox to left even more
                    paddleY - gameState.ballSize * 1.5, // Extend paddle hitbox up more
                    paddleWidth + gameState.userPaddleExtraWidth * 3, // Widen the hitbox significantly
                    paddleHeight + gameState.ballSize * 3 // Extend paddle hitbox down more
                );
                
                // Enhanced line intersection test - check if the ball's path crosses the paddle
                let lineIntersection = false;
                
                // Check for path intersection even when ball is moving very fast
                const dx = x - lastX;
                const dy = y - lastY;
                
                // Check for any significant movement
                if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                    // Check for intersection with any edge of paddle (left, right, top, bottom)
                    
                    // Left edge
                    if (dx !== 0) { // Avoid division by zero
                        const t1 = (paddleX - lastX) / dx;
                        if (t1 >= 0 && t1 <= 1) {
                            const y1 = lastY + t1 * dy;
                            if (y1 >= paddleY - gameState.ballSize && y1 <= paddleY + paddleHeight + gameState.ballSize) {
                                lineIntersection = true;
                            }
                        }
                    }
                    
                    // Right edge
                    if (dx !== 0) { // Avoid division by zero
                        const t2 = (paddleX + paddleWidth - lastX) / dx;
                        if (t2 >= 0 && t2 <= 1) {
                            const y2 = lastY + t2 * dy;
                            if (y2 >= paddleY - gameState.ballSize && y2 <= paddleY + paddleHeight + gameState.ballSize) {
                                lineIntersection = true;
                            }
                        }
                    }
                    
                    // Top edge
                    if (dy !== 0) { // Avoid division by zero
                        const t3 = (paddleY - lastY) / dy;
                        if (t3 >= 0 && t3 <= 1) {
                            const x3 = lastX + t3 * dx;
                            if (x3 >= paddleX - gameState.ballSize && x3 <= paddleX + paddleWidth + gameState.ballSize) {
                                lineIntersection = true;
                            }
                        }
                    }
                    
                    // Bottom edge
                    if (dy !== 0) { // Avoid division by zero
                        const t4 = (paddleY + paddleHeight - lastY) / dy;
                        if (t4 >= 0 && t4 <= 1) {
                            const x4 = lastX + t4 * dx;
                            if (x4 >= paddleX - gameState.ballSize && x4 <= paddleX + paddleWidth + gameState.ballSize) {
                                lineIntersection = true;
                            }
                        }
                    }
                }
                
                return normalCollision || tunneled || extendedCollision || lineIntersection;
            }
            
            function gameLoop() {
                if (!pongActive) return;
                
                // If the ball is not visible (during explosion), skip movement and collision
                if (!gameState.ballVisible) {
                    animationFrame = requestAnimationFrame(gameLoop);
                    return;
                }
                
                // Store previous position for tracer and collision detection
                gameState.lastBallX = gameState.ballX;
                gameState.lastBallY = gameState.ballY;
                
                // Add current position to history for tracer
                ballPositions.unshift({x: gameState.ballX, y: gameState.ballY});
                
                // Limit the history size
                if (ballPositions.length > tracerCount) {
                    ballPositions.pop();
                }
                
                // Update tracer elements
                tracers.forEach((tracer, index) => {
                    if (index < ballPositions.length) {
                        const pos = ballPositions[index];
                        tracer.style.left = pos.x + 'px';
                        tracer.style.top = pos.y + 'px';
                        tracer.style.width = (gameState.ballSize - index * 2) + 'px';
                        tracer.style.height = (gameState.ballSize - index * 2) + 'px';
                        tracer.style.opacity = (0.6 - index * 0.1);
                    } else {
                        tracer.style.opacity = '0';
                    }
                });
                
                // Decrease collision cooldown if active
                if (gameState.collisionCooldown > 0) {
                    gameState.collisionCooldown--;
                }
                
                // Sub-stepping for better collision detection (prevents tunneling)
                const subStepX = gameState.ballSpeedX / gameState.subSteps;
                const subStepY = gameState.ballSpeedY / gameState.subSteps;
                
                // Temporary variables to check if a collision happened during any sub-step
                let hadWallCollision = false;
                let hadPaddleCollision = false;
                
                // Track last clean position before any collision
                let lastCleanX = gameState.lastBallX;
                let lastCleanY = gameState.lastBallY;
                
                for (let step = 0; step < gameState.subSteps; step++) {
                    // Update ball position for this sub-step
                    gameState.ballX += subStepX;
                    gameState.ballY += subStepY;
                    
                    // Ball collision with top and bottom walls - IMPROVED
                    if (gameState.ballY <= gameState.ballSize/2 || gameState.ballY >= window.innerHeight - gameState.ballSize/2) {
                        // Calculate current ball velocity vector
                        const currentSpeed = Math.sqrt(gameState.ballSpeedX * gameState.ballSpeedX + gameState.ballSpeedY * gameState.ballSpeedY);
                        
                        // Reverse Y direction with a more significant push
                        gameState.ballSpeedY = -gameState.ballSpeedY;
                        
                        // Ensure Y velocity isn't too small (prevents horizontal movement)
                        if (Math.abs(gameState.ballSpeedY) < 1.0) {
                            // If Y velocity is too small, give it a stronger minimum value
                            gameState.ballSpeedY = (gameState.ballSpeedY > 0 ? 1 : -1) * Math.max(1.5, currentSpeed * 0.4);
                        }
                        
                        // Push the ball out of the wall with more force
                        if (gameState.ballY <= gameState.ballSize/2) {
                            gameState.ballY = gameState.ballSize/2 + 5; // Increased push out distance significantly
                        } else if (gameState.ballY >= window.innerHeight - gameState.ballSize/2) {
                            gameState.ballY = window.innerHeight - gameState.ballSize/2 - 5; // Increased push out distance significantly
                        }
                        
                        // Add more randomness to prevent predictable patterns
                        gameState.ballSpeedX += (Math.random() - 0.5) * 0.5;
                        
                        hadWallCollision = true;
                        
                        // Break out of this sub-step after wall collision to prevent further issues
                        break;
                    }
                    
                    // Only check paddle collisions if cooldown is not active
                    if (gameState.collisionCooldown === 0) {
                        // Left paddle collision with expanded hitbox
                        const leftPaddleX = 20;
                        if (checkPaddleCollision(
                            gameState.ballX, 
                            gameState.ballY, 
                            leftPaddleX, 
                            gameState.leftPaddleY, 
                            gameState.paddleWidth,
                            gameState.paddleHeight
                        )) {
                            // Only bounce if moving toward the paddle
                            if (gameState.ballSpeedX < 0) {
                                // Calculate relative impact position (0 = top of paddle, 1 = bottom of paddle)
                                const relativeImpact = (gameState.ballY - gameState.leftPaddleY) / gameState.paddleHeight;
                                
                                // Angle calculation: -45 to 45 degrees based on where it hits
                                const bounceAngle = (relativeImpact - 0.5) * Math.PI / 2;
                                
                                // Ball speed after collision - maintain total speed but change direction
                                const speed = Math.sqrt(gameState.ballSpeedX * gameState.ballSpeedX + gameState.ballSpeedY * gameState.ballSpeedY);
                                
                                // Reverse X direction and adjust Y based on impact point
                                gameState.ballSpeedX = Math.abs(speed * Math.cos(bounceAngle));
                                gameState.ballSpeedY = speed * Math.sin(bounceAngle);
                                
                                // Ensure ball is outside the paddle - with greater push
                                gameState.ballX = leftPaddleX + gameState.paddleWidth + gameState.ballSize/2 + 5;
                                
                                // Set collision cooldown (prevents multiple collisions in quick succession)
                                gameState.collisionCooldown = 10;
                                
                                hadPaddleCollision = true;
                                
                                // Break out of the sub-steps after collision
                                break;
                            }
                        }
                        
                        // Right paddle (user paddle) collision with ultra-robust detection - IMPROVED
                        const rightPaddleX = window.innerWidth - 20 - gameState.paddleWidth;
                        
                        // Improved user paddle collision detection with more aggressive parameters
                        if (checkUserPaddleCollision(
                            gameState.ballX, 
                            gameState.ballY,
                            lastCleanX,
                            lastCleanY,
                            rightPaddleX, 
                            gameState.rightPaddleY, 
                            gameState.paddleWidth,
                            gameState.paddleHeight
                        )) {
                            // Always bounce regardless of direction to fix tunneling issues
                            // Calculate relative impact position (0 = top of paddle, 1 = bottom of paddle)
                            const relativeImpact = (gameState.ballY - gameState.rightPaddleY) / gameState.paddleHeight;
                            
                            // Angle calculation: -45 to 45 degrees based on where it hits
                            const bounceAngle = (relativeImpact - 0.5) * Math.PI / 2;
                            
                            // Ball speed after collision - maintain total speed but change direction
                            const speed = Math.sqrt(gameState.ballSpeedX * gameState.ballSpeedX + gameState.ballSpeedY * gameState.ballSpeedY);
                            
                            // Reverse X direction and adjust Y based on impact point
                            gameState.ballSpeedX = -Math.abs(speed * Math.cos(bounceAngle));
                            gameState.ballSpeedY = speed * Math.sin(bounceAngle);
                            
                            // Always ensure ball is outside the paddle, even if it tunneled through
                            // Use a larger push out value to prevent sticking
                            gameState.ballX = rightPaddleX - gameState.ballSize/2 - 5;
                            
                            // Set collision cooldown (prevents multiple collisions in quick succession)
                            gameState.collisionCooldown = 10;
                            
                            hadPaddleCollision = true;
                            
                            // Break out of the sub-steps after collision
                            break;
                        }
                    }
                    
                    // Update last clean position if no collision happened
                    lastCleanX = gameState.ballX;
                    lastCleanY = gameState.ballY;
                    
                    // Check for scoring in each sub-step
                    if (gameState.ballX <= 0) {
                        gameState.rightPoints++;
                        rightScore.textContent = gameState.rightPoints;
                        
                        // Add glow effect to right paddle (player's paddle)
                        rightPaddle.classList.add('paddle-glow');
                        setTimeout(() => {
                            rightPaddle.classList.remove('paddle-glow');
                        }, 1000);
                        
                        // Increase CPU difficulty after player scores 5 points
                        if (gameState.rightPoints >= 5 && gameState.cpuDifficultyStage < 5) {
                            gameState.cpuAccuracy = Math.min(0.5 + ((gameState.rightPoints - 4) * gameState.cpuSkillIncrease), 1.0);
                            gameState.cpuDifficultyStage++;
                        }
                        
                        // Calculate total score
                        let totalScore = gameState.leftPoints + gameState.rightPoints;
                        
                        // Check for explosion threshold
                        if (totalScore === gameState.nextExplosionThreshold) {
                            // Create explosion at current ball position
                            createExplosion(gameState.ballX, gameState.ballY);
                            gameState.explosionOccurred = true;
                            gameState.lastExplosionScore = totalScore;
                            
                            // Update explosion threshold for next time
                            if (gameState.nextExplosionThreshold === 50) {
                                gameState.nextExplosionThreshold = 100;
                                gameState.postExplosionBoost = true; // Switch to 20% boosts after 50
                                console.log("🎆 EXPLOSION AT 50 POINTS! 🎆 Next explosion at 100 points. Speed will now increase by 20% every 5 goals.");
                            } else if (gameState.nextExplosionThreshold === 100) {
                                gameState.nextExplosionThreshold = 150;
                                console.log("🎆 EXPLOSION AT 100 POINTS! 🎆 Next explosion at 150 points.");
                            } else {
                                gameState.nextExplosionThreshold += 50;
                                console.log(`🎆 EXPLOSION AT ${totalScore} POINTS! 🎆 Next explosion at ${gameState.nextExplosionThreshold} points.`);
                            }
                            
                            // Reset speed boost stage - will be done in createExplosion function
                        } else {
                            // Check if we need to apply speed boost (every 5 goals since last explosion)
                            let goalsSinceLastExplosion = totalScore - gameState.lastExplosionScore;
                            
                            if (goalsSinceLastExplosion > 0 && goalsSinceLastExplosion % 5 === 0) {
                                gameState.speedBoostStage++;
                                
                                // Log the speed boost with the correct percentage
                                let boostPercentage = gameState.postExplosionBoost ? 20 : 25;
                                let totalBoost = gameState.postExplosionBoost ? 
                                    Math.pow(1.20, gameState.speedBoostStage).toFixed(2) : 
                                    Math.pow(1.25, gameState.speedBoostStage).toFixed(2);
                                
                                console.log(`Speed boost stage ${gameState.speedBoostStage}: Ball is now ${totalBoost}x original speed (+${boostPercentage}% per stage)`);
                            }
                            
                            resetBall();
                        }
                        
                        break;
                    }
                    
                    if (gameState.ballX >= window.innerWidth) {
                        gameState.leftPoints++;
                        leftScore.textContent = gameState.leftPoints;
                        
                        // Add glow effect to left paddle (CPU's paddle)
                        leftPaddle.classList.add('paddle-glow');
                        setTimeout(() => {
                            leftPaddle.classList.remove('paddle-glow');
                        }, 1000);
                        
                        // Calculate total score
                        let totalScore = gameState.leftPoints + gameState.rightPoints;
                        
                        // Check for explosion threshold
                        if (totalScore === gameState.nextExplosionThreshold) {
                            // Create explosion at current ball position
                            createExplosion(gameState.ballX, gameState.ballY);
                            gameState.explosionOccurred = true;
                            gameState.lastExplosionScore = totalScore;
                            
                            // Update explosion threshold for next time
                            if (gameState.nextExplosionThreshold === 50) {
                                gameState.nextExplosionThreshold = 100;
                                gameState.postExplosionBoost = true; // Switch to 20% boosts after 50
                                console.log("🎆 EXPLOSION AT 50 POINTS! 🎆 Next explosion at 100 points. Speed will now increase by 20% every 5 goals.");
                            } else if (gameState.nextExplosionThreshold === 100) {
                                gameState.nextExplosionThreshold = 150;
                                console.log("🎆 EXPLOSION AT 100 POINTS! 🎆 Next explosion at 150 points.");
                            } else {
                                gameState.nextExplosionThreshold += 50;
                                console.log(`🎆 EXPLOSION AT ${totalScore} POINTS! 🎆 Next explosion at ${gameState.nextExplosionThreshold} points.`);
                            }
                            
                            // Reset speed boost stage - will be done in createExplosion function
                        } else {
                            // Check if we need to apply speed boost (every 5 goals since last explosion)
                            let goalsSinceLastExplosion = totalScore - gameState.lastExplosionScore;
                            
                            if (goalsSinceLastExplosion > 0 && goalsSinceLastExplosion % 5 === 0) {
                                gameState.speedBoostStage++;
                                
                                // Log the speed boost with the correct percentage
                                let boostPercentage = gameState.postExplosionBoost ? 20 : 25;
                                let totalBoost = gameState.postExplosionBoost ? 
                                    Math.pow(1.20, gameState.speedBoostStage).toFixed(2) : 
                                    Math.pow(1.25, gameState.speedBoostStage).toFixed(2);
                                
                                console.log(`Speed boost stage ${gameState.speedBoostStage}: Ball is now ${totalBoost}x original speed (+${boostPercentage}% per stage)`);
                            }
                            
                            resetBall();
                        }
                        
                        break;
                    }
                }
                
                // Play sounds based on collision results
                if (hadPaddleCollision) {
                    playPaddleHitSound();
                }
                
                // CPU AI (left paddle) with variable accuracy
                const shouldTrackBall = Math.random() < gameState.cpuAccuracy;
                
                if (shouldTrackBall && gameState.ballSpeedX < 0) { // Only track when ball is moving toward CPU
                    const paddleCenter = gameState.leftPaddleY + gameState.paddleHeight/2;
                    const targetY = gameState.ballY;
                    
                    if (paddleCenter < targetY - 15) {
                        gameState.leftPaddleY += gameState.paddleSpeed;
                    } else if (paddleCenter > targetY + 15) {
                        gameState.leftPaddleY -= gameState.paddleSpeed;
                    }
                } else {
                    // Add slight random movement when not tracking to make it look more natural
                    if (Math.random() > 0.95) {
                        gameState.leftPaddleY += (Math.random() - 0.5) * gameState.paddleSpeed * 2;
                    }
                }
                
                // Keep paddles within bounds
                gameState.leftPaddleY = Math.max(0, Math.min(window.innerHeight - gameState.paddleHeight, gameState.leftPaddleY));
                gameState.rightPaddleY = Math.max(0, Math.min(window.innerHeight - gameState.paddleHeight, gameState.rightPaddleY));
                
                // Update DOM elements
                ball.style.left = gameState.ballX + 'px';
                ball.style.top = gameState.ballY + 'px';
                leftPaddle.style.top = gameState.leftPaddleY + 'px';
                rightPaddle.style.top = gameState.rightPaddleY + 'px';
                
                animationFrame = requestAnimationFrame(gameLoop);
            }
            
            // Mouse movement to control right paddle
            document.addEventListener('mousemove', (e) => {
                // Reset timer only if game hasn't started yet
                if (!gameStarted) {
                    resetInactivityTimer();
                }
                
                if (pongActive) {
                    gameState.rightPaddleY = e.clientY - gameState.paddleHeight/2; // Center paddle on mouse
                }
            });
            
            // Substantive interactions should reset timer and potentially stop game
            const substantiveEvents = ['click', 'keydown', 'touchstart'];
            substantiveEvents.forEach(event => {
                document.addEventListener(event, () => {
                    // Clicking anywhere once game has started will stop it
                    if (gameStarted) {
                        stopPong();
                    }
                    resetInactivityTimer();
                });
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (pongActive) {
                    resetBall();
                }
            });
            
            // Start inactivity timer
            resetInactivityTimer();
        })();
        
        // Card video playback
        document.querySelectorAll('.card').forEach(card => {
            const video = card.querySelector('.card-video');
            const demoLink = card.querySelector('.demo-btn').getAttribute('href');

            // Make entire card clickable
            card.addEventListener('click', (e) => {
                // Only navigate if not clicking on the buttons
                if (!e.target.closest('.card-buttons')) {
                    window.open(demoLink, '_blank');
                }
            });
            
            // Add touch event listeners for mobile
            card.addEventListener('touchstart', (e) => {
                // Play video on touch start
                if (video && !video.playing) {
                    video.play();
                }
            });
            
            card.addEventListener('touchend', (e) => {
                // Only navigate if not touching the buttons
                if (!e.target.closest('.card-buttons')) {
                    // Prevent default to avoid double-triggering with click
                    e.preventDefault();
                    window.open(demoLink, '_blank');
                }
            });
            
            card.addEventListener('mouseenter', () => {
                if (video) {
                    video.play();
                }
            });
            
            card.addEventListener('mouseleave', () => {
                if (video) {
                    video.pause();
                    video.currentTime = 0;
                }
            });
        });
        
        // Add touch support for Pong game
        document.addEventListener('touchmove', (e) => {
            // Reset timer only if game hasn't started yet
            if (!gameStarted) {
                resetInactivityTimer();
            }
            
            if (pongActive && e.touches.length > 0) {
                // Get the first touch
                const touch = e.touches[0];
                // Control paddle with touch Y position
                gameState.rightPaddleY = touch.clientY - gameState.paddleHeight/2;
                
                // Prevent scrolling while playing
                e.preventDefault();
            }
        }, { passive: false });
        
        // Add touch listeners for stopping game
        document.addEventListener('touchstart', () => {
            if (gameStarted) {
                stopPong();
            }
            resetInactivityTimer();
        });
    </script>
</body>
</html>
